# file opened: main.asm
  1   0000              ;===========================================================================
  2   0000              ; main.asm
  3   0000              ;===========================================================================
  4   0000
  5   0000              NEX:    equ 1   ;  1=Create nex file, 0=create sna file
  6   0000
  7   0000                  IF NEX == 0
  8   0000 ~                    DEVICE ZXSPECTRUM128
  9   0000                  ELSE
 10   0000                      DEVICE ZXSPECTRUMNEXT
 11   0000                  ENDIF
 12   0000
 13   0000                  ORG 0x4000
 14   4000 00 00 00...      defs 0x6000 - $    ; move after screen area
 15   6000 00           screen_top: defb    0   ; WPMEMx
 16   6001
 17   6001
 18   6001              ;===========================================================================
 19   6001              ; Persistent watchpoint.
 20   6001              ; Change WPMEMx (remove the 'x' from WPMEMx) below to activate.
 21   6001              ; If you do so the program will hit a breakpoint when it tries to
 22   6001              ; write to the first byte of the 3rd line.
 23   6001              ; When program breaks in the fill_memory sub routine please hover over hl
 24   6001              ; to see that it contains 0x5804 or COLOR_SCREEN+64.
 25   6001              ;===========================================================================
 26   6001
 27   6001              ; WPMEMx 0x5840, 1, w
 28   6001
 29   6001
 30   6001              ;===========================================================================
 31   6001              ; Include modules
 32   6001              ;===========================================================================
 33   6001                  include "utilities.asm"
# file opened: utilities.asm
  1+  6001              ;===========================================================================
  2+  6001              ; utilities.asm
  3+  6001              ; Submodule for some common routines.
  4+  6001              ;===========================================================================
  5+  6001
  6+  6001              ; Some constants
  7+  6001              PAUSE_TIME:     equ 500   ; 0.5 sec
  8+  6001
  9+  6001
 10+  6001              ; Pauses for a while.
 11+  6001              ; de: wait time, ca. de*0.1ms
 12+  6001              pause:
 13+  6001              ;	ret	; comment this line if you would like to see a pause between drawing of the lines.
 14+  6001
 15+  6001 F5           	push af
 16+  6002 C5           	push bc
 17+  6003
 18+  6003              pause_loop_l2:
 19+  6003 06 1A        	ld b,26
 20+  6005              pause_loop_l1:
 21+  6005 10 FE        	djnz pause_loop_l1 ; 1 cycle should be roughly 100us=0.1ms
 22+  6007
 23+  6007 1B           	dec de
 24+  6008 7A           	ld a,d
 25+  6009 B3           	or e
 26+  600A 20 F7        	jr nz,pause_loop_l2
 27+  600C
 28+  600C C1           	pop bc
 29+  600D F1           	pop af
 30+  600E C9           	ret
 31+  600F
 32+  600F
 33+  600F
 34+  600F
 35+  600F              ;===========================================================================
 36+  600F              ; Writes a color to the border and waits on keypress
 37+  600F              ; of SPACE.
 38+  600F              ; Used for visual debugging.
 39+  600F              ; Changes:
 40+  600F              ;   A
 41+  600F              ;===========================================================================
 42+  600F              	MACRO WAIT_SPACE color?
 43+  600F ~            	ld a,color?
 44+  600F ~            	out (BORDER),a
 45+  600F ~            	; Wait on key press
 46+  600F ~            .not_pressed:
 47+  600F ~            	ld a,HIGH PORT_KEYB_BNMSHIFTSPACE
 48+  600F ~            	in a,(LOW PORT_KEYB_BNMSHIFTSPACE)
 49+  600F ~            	bit 0,a	; SPACE
 50+  600F ~            	jr nz,.not_pressed
 51+  600F ~            	; Wait on key release
 52+  600F ~            .pressed:
 53+  600F ~            	ld a,HIGH PORT_KEYB_BNMSHIFTSPACE
 54+  600F ~            	in a,(LOW PORT_KEYB_BNMSHIFTSPACE)
 55+  600F ~            	bit 0,a	; SPACE
 56+  600F ~            	jr z,.pressed
 57+  600F              	ENDM
 58+  600F
# file closed: utilities.asm
 34   600F                  include "fill.asm"
# file opened: fill.asm
  1+  600F              ;===========================================================================
  2+  600F              ; fill.asm
  3+  600F              ; Submodule with memory fill routines.
  4+  600F              ;===========================================================================
  5+  600F
  6+  600F              ; Some constants
  7+  600F              BCKG_LINE_SIZE:  equ     32
  8+  600F
  9+  600F              ; Colors
 10+  600F              BLACK:          equ 0<<3
 11+  600F              BLUE:           equ 1<<3
 12+  600F              RED:            equ 2<<3
 13+  600F              MAGENTA:        equ 3<<3
 14+  600F              GREEN:          equ 4<<3
 15+  600F              CYAN:           equ 5<<3
 16+  600F              YELLOW:         equ 6<<3
 17+  600F              WHITE:          equ 7<<3
 18+  600F
 19+  600F
 20+  600F              ; Fills a memory area with a certain value.
 21+  600F              ; a = contains the fill value.
 22+  600F              ; hl = address to fill
 23+  600F              ; bc = size
 24+  600F              fill_memory:
 25+  600F 77               ld (hl),a
 26+  6010 5D               ld e,l
 27+  6011 54               ld d,h
 28+  6012 13               inc de
 29+  6013 0B               dec bc
 30+  6014 ED B0            ldir
 31+  6016 C9               ret
 32+  6017
 33+  6017
 34+  6017              ; Fills a background line with a color.
 35+  6017              ; IN:
 36+  6017              ; a = color
 37+  6017              ; de = points to background screen
 38+  6017              ; OUT:
 39+  6017              ; de = pointing to next line
 40+  6017              fill_bckg_line:
 41+  6017 01 20 00         ld bc,BCKG_LINE_SIZE
 42+  601A 6B               ld l,e
 43+  601B 62               ld h,d
 44+  601C CD 0F 60         call fill_memory
 45+  601F                  ; check that destination address is still in screen background
 46+  601F 21 FF 5A         ld hl,COLOR_SCREEN+COLOR_SCREEN_SIZE-1
 47+  6022 B7               or a    ; clear carry
 48+  6023 ED 52            sbc hl,de ; compare
 49+  6025 F0               ret p
 50+  6026                  ; ld start address
 51+  6026 11 00 58         ld de,COLOR_SCREEN
 52+  6029 C9               ret
 53+  602A
 54+  602A
 55+  602A              ; Increments the fill_colors_ptr and resets it if necessary.
 56+  602A              inc_fill_colors_ptr:
 57+  602A 2A 3F 60         ld hl,(fill_colors_ptr)
 58+  602D 23               inc hl
 59+  602E 22 3F 60         ld (fill_colors_ptr),hl
 60+  6031
 61+  6031                  ; check if out of range
 62+  6031 01 46 60         ld bc,fill_colors_end
 63+  6034 B7               or a    ; clear carry
 64+  6035 ED 42            sbc hl,bc ; compare
 65+  6037 F8               ret m
 66+  6038
 67+  6038                  ; reset
 68+  6038 21 41 60         ld hl,fill_colors
 69+  603B 22 3F 60         ld (fill_colors_ptr),hl
 70+  603E C9               ret
 71+  603F
 72+  603F
 73+  603F              ; Pointer to fill colors.
 74+  603F 00 00        fill_colors_ptr:    defw 0
 75+  6041
 76+  6041              ; Contains the colors for the lines. Each entry represnts the color for one line.
 77+  6041              fill_colors:
 78+  6041 10 30 08 20      defb RED, YELLOW, BLUE, GREEN, MAGENTA
 78+  6045 18
 79+  6046              fill_colors_end:
 80+  6046 00               defb 0  ; WPMEM
 81+  6047
 82+  6047
# file closed: fill.asm
 35   6047                  include "clearscreen.asm"
# file opened: clearscreen.asm
  1+  6047              ;===========================================================================
  2+  6047              ; clearscreen.asm
  3+  6047              ; Submodule to clear the entire screen.
  4+  6047              ;===========================================================================
  5+  6047
  6+  6047              ; Some constants
  7+  6047              SCREEN:         equ 0x4000
  8+  6047              SCREEN_SIZE:    equ 0x1800
  9+  6047
 10+  6047              COLOR_SCREEN:       equ 0x5800
 11+  6047              COLOR_SCREEN_SIZE:  equ 0x0300
 12+  6047
 13+  6047
 14+  6047              ; Clears the screen
 15+  6047              clear_screen:
 16+  6047 AF               xor a
 17+  6048 01 00 18         ld bc,SCREEN_SIZE
 18+  604B 21 00 40         ld hl,SCREEN
 19+  604E CD 0F 60         call fill_memory
 20+  6051 C9               ret
 21+  6052
 22+  6052
 23+  6052              ; Clears the background
 24+  6052              clear_backg:
 25+  6052 AF               xor a
 26+  6053 CD 57 60         call fill_backg
 27+  6056 C9               ret
 28+  6057
 29+  6057
 30+  6057              ; Fills the background with fore and background color.
 31+  6057              ; a contains the fill color.
 32+  6057              fill_backg:
 33+  6057 01 00 03         ld bc,COLOR_SCREEN_SIZE
 34+  605A 21 00 58         ld hl,COLOR_SCREEN
 35+  605D CD 0F 60         call fill_memory
 36+  6060 C9               ret
 37+  6061
 38+  6061
 39+  6061
 40+  6061
# file closed: clearscreen.asm
 36   6061
 37   6061                  include "dezog.asm"
# file opened: dezog.asm
  1+  6061              ;===========================================================================
  2+  6061              ; dezog.asm
  3+  6061              ;
  4+  6061              ; Subroutines to cooperate with the debugged program.
  5+  6061              ;===========================================================================
  6+  6061
  7+  6061
  8+  6061              ;===========================================================================
  9+  6061              ; Magic number addresses to recognize the debugger
 10+  6061              ;===========================================================================
 11+  6061              dezog_magic_number_a:     equ 0x0000     ; Address 0x0000 (0xE000)
 12+  6061              dezog_magic_number_b:     equ 0x0001
 13+  6061              dezog_magic_number_c:     equ 0x0066      ; Address 0x0066 (0xE066)
 14+  6061              dezog_magic_number_d:     equ 0x0067
 15+  6061
 16+  6061              ; The corresponding values
 17+  6061              DEZOG_MAGIC_NUMBER_VALUE_A:	equ 0x18
 18+  6061              DEZOG_MAGIC_NUMBER_VALUE_B:	equ 0x64
 19+  6061              DEZOG_MAGIC_NUMBER_VALUE_C:	equ 0xF5
 20+  6061              DEZOG_MAGIC_NUMBER_VALUE_D:	equ 0xED
 21+  6061
 22+  6061
 23+  6061
 24+  6061              ;===========================================================================
 25+  6061              ; Initializes the given bank with debugger code.
 26+  6061              ; 8 bytes at address 0 and 14 bytes at address 66h.
 27+  6061              ; If slot 0 does not contain the bank for DeZog or a
 28+  6061              ; already modified bank the function does nothing.
 29+  6061              ; Parameters:
 30+  6061              ;   A = bank to initialize.
 31+  6061              ; Changes:
 32+  6061              ;   AF
 33+  6061              ; ===========================================================================
 34+  6061              dezog_init_slot0_bank:
 35+  6061              	; Put the bank as parameter on the stack
 36+  6061 32 7E 60     	ld (.push+2),a
 37+  6064
 38+  6064              	; First check if slot0 already contains a bank with modifications for DeZog.
 39+  6064 3A 00 00     	ld a,(dezog_magic_number_a)	; ok (suppress warning)
 40+  6067 FE 18        	cp DEZOG_MAGIC_NUMBER_VALUE_A
 41+  6069 C0           	ret nz
 42+  606A 3A 01 00     	ld a,(dezog_magic_number_b)	; ok (suppress warning)
 43+  606D FE 64        	cp DEZOG_MAGIC_NUMBER_VALUE_B
 44+  606F C0           	ret nz
 45+  6070 3A 66 00     	ld a,(dezog_magic_number_c)	; ok (suppress warning)
 46+  6073 FE F5        	cp DEZOG_MAGIC_NUMBER_VALUE_C
 47+  6075 C0           	ret nz
 48+  6076 3A 67 00     	ld a,(dezog_magic_number_d)	; ok (suppress warning)
 49+  6079 FE ED        	cp DEZOG_MAGIC_NUMBER_VALUE_D
 50+  607B C0           	ret nz
 51+  607C
 52+  607C              	; Push a 2=Execute "Function: init_slot0_bank"
 53+  607C              .push:
 54+  607C ED 8A 00 02  	defb 0xED, 0x8A, 0, 2	; 0x0002
 55+  6080              	; Push a 0x0000 on the stack. With this the call is distinguished from
 56+  6080              	; a SW breakpoint.
 57+  6080 ED 8A 00 00  	defb 0xED, 0x8A, 0, 0	; push 0x0000
 58+  6084 C3 00 00     	jp 0x0000
 59+  6087
# file closed: dezog.asm
 38   6087
 39   6087                  ; Normally you would assemble the unit tests in a separate target
 40   6087                  ; in the makefile.
 41   6087                  ; As this is a very short program and for simplicity the
 42   6087                  ; unit tests and the main program are assembled in the same binary.
 43   6087                  include "unit_tests.asm"
# file opened: unit_tests.asm
  1+  6087              ;========================================================
  2+  6087              ; unit_tests.asm
  3+  6087              ;
  4+  6087              ; Collects and executes all unit tests.
  5+  6087              ;========================================================
  6+  6087
  7+  6087                  include "unit_tests.inc"
# file opened: unit_tests.inc
  1++ 6087              ;--------------------------------------------------------
  2++ 6087              ; unit_tests.inc
  3++ 6087              ;
  4++ 6087              ; Contains all macros used for unit testing.
  5++ 6087              ;--------------------------------------------------------
  6++ 6087
  7++ 6087                IFDEF _SJASMPLUS
  8++ 6087                  ; -----------------------------------------------------------
  9++ 6087                  ; Code for sjasmplus
 10++ 6087
 11++ 6087                  MACRO UNITTEST_INITIALIZE
 12++ 6087 ~
 13++ 6087 ~                ; Called to call each unit test.
 14++ 6087 ~            @UNITTEST_TEST_WRAPPER:
 15++ 6087 ~                    di
 16++ 6087 ~                    ld sp,UNITTEST_STACK
 17++ 6087 ~            @UNITTEST_CALL_ADDR:
 18++ 6087 ~                    call 0x0000 ; Will be changed by the z80 unit tests.
 19++ 6087 ~                    nop
 20++ 6087 ~
 21++ 6087 ~            @UNITTEST_TEST_READY_RETURN_FAILURE:
 22++ 6087 ~                    jr UNITTEST_TEST_READY_RETURN_FAILURE	; A breakpoint will be set here. The unit test will normally not return here but at UNITTEST_TEST_READY_SUCCESS
 23++ 6087 ~
 24++ 6087 ~            @UNITTEST_TEST_READY_FAILURE:
 25++ 6087 ~                    nop
 26++ 6087 ~            @UNITTEST_TEST_READY_FAILURE_BREAKPOINT:
 27++ 6087 ~                    ret 	; A breakpoint will be set here. The next step will return to the failed test case
 28++ 6087 ~
 29++ 6087 ~            @UNITTEST_TEST_READY_SUCCESS:
 30++ 6087 ~                    jr UNITTEST_TEST_READY_SUCCESS	; A breakpoint will be set here.
 31++ 6087 ~
 32++ 6087 ~            @UNITTEST_MIN_STACK_GUARD:
 33++ 6087 ~                    defw 0	; A write watchpoint will be set here to guard the stack
 34++ 6087 ~                    defs 2*50	; Stack depth of 50 should be enough
 35++ 6087 ~            @UNITTEST_STACK:
 36++ 6087 ~
 37++ 6087 ~            @UNITTEST_MAX_STACK_GUARD:
 38++ 6087 ~                    defw 0	; A write watchpoint will be set here to guard the stack
 39++ 6087 ~
 40++ 6087 ~            @UNITTEST_SAVE_REG:
 41++ 6087 ~                    defw 0  ; Used to save register values.
 42++ 6087 ~
 43++ 6087 ~
 44++ 6087 ~                ; The unit test initialization. Provided by the user.
 45++ 6087 ~            @UNITTEST_START:
 46++ 6087 ~                    ; Disable interrupts
 47++ 6087 ~                    di
 48++ 6087 ~                    ; Flow through.
 49++ 6087 ~                    ; Directly after the UNITTEST_INITIALIZE macro the user
 50++ 6087 ~                    ; should put his test initialization code.
 51++ 6087 ~                    ; Note: the stack pointer does not need to be set up.
 52++ 6087 ~
 53++ 6087                  ENDM
 54++ 6087
 55++ 6087
 56++ 6087                  ; Macro that must be used at the end of the test case (instead of a ret).
 57++ 6087                  MACRO TC_END
 58++ 6087 ~                    jp UNITTEST_TEST_READY_SUCCESS
 59++ 6087                  ENDM
 60++ 6087
 61++ 6087
 62++ 6087                  ; Tests a memory address for a specific byte value.
 63++ 6087                  MACRO TEST_MEMORY_BYTE addr?, value?
 64++ 6087 ~                    ld (UNITTEST_SAVE_REG),a
 65++ 6087 ~                    ld a,(addr?)
 66++ 6087 ~                    cp value?
 67++ 6087 ~                    call nz,UNITTEST_TEST_READY_FAILURE
 68++ 6087 ~                    ld a,(UNITTEST_SAVE_REG)
 69++ 6087                  ENDM
 70++ 6087
 71++ 6087                  ; Tests a memory address for a specific word value.
 72++ 6087                  ; If the test fails the '(addr)' can be found in DE.
 73++ 6087                  MACRO TEST_MEMORY_WORD addr?, value?
 74++ 6087 ~                    push de
 75++ 6087 ~                    push hl
 76++ 6087 ~                    ld hl,value?
 77++ 6087 ~                    ld de,(addr?)
 78++ 6087 ~                    or a
 79++ 6087 ~                    sbc hl,de
 80++ 6087 ~                    pop hl
 81++ 6087 ~                    call nz,UNITTEST_TEST_READY_FAILURE ; de = (addr)
 82++ 6087 ~                    pop de
 83++ 6087                  ENDM
 84++ 6087
 85++ 6087                  ; Creates a failure when reached.
 86++ 6087                  MACRO TEST_FAIL
 87++ 6087 ~                    call UNITTEST_TEST_READY_FAILURE
 88++ 6087                  ENDM
 89++ 6087
 90++ 6087                  ; Tests A for a specific value.
 91++ 6087                  MACRO TEST_A value?
 92++ 6087 ~                    cp value?
 93++ 6087 ~                    call nz,UNITTEST_TEST_READY_FAILURE
 94++ 6087 ~                    nop
 95++ 6087                  ENDM
 96++ 6087
 97++ 6087                  ; Tests that A is not equal to a specific value.
 98++ 6087                  MACRO TEST_A_UNEQUAL value?
 99++ 6087 ~                    cp value?
100++ 6087 ~                    call z,UNITTEST_TEST_READY_FAILURE
101++ 6087 ~                    nop
102++ 6087                  ENDM
103++ 6087
104++ 6087                  ; Tests a single register for a specific value.
105++ 6087                  ; E.g. TEST_REG b, 6 ; Tests if register b == 6
106++ 6087                  MACRO TEST_REG reg?, value?
107++ 6087 ~                    ld (UNITTEST_SAVE_REG),a
108++ 6087 ~                    ld a,reg?
109++ 6087 ~                    cp value?
110++ 6087 ~                    call nz,UNITTEST_TEST_READY_FAILURE
111++ 6087 ~                    ld a,(UNITTEST_SAVE_REG)
112++ 6087                  ENDM
113++ 6087
114++ 6087                  ; Tests that a single register is not a specific value.
115++ 6087                  ; E.g. TEST_REG_UNEQUAL b, 6 ; Tests if register b != 6
116++ 6087                  MACRO TEST_REG_UNEQUAL reg?, value?
117++ 6087 ~                    ld (UNITTEST_SAVE_REG),a
118++ 6087 ~                    ld a,reg?
119++ 6087 ~                    cp value?
120++ 6087 ~                    call z,UNITTEST_TEST_READY_FAILURE
121++ 6087 ~                    ld a,(UNITTEST_SAVE_REG)
122++ 6087                  ENDM
123++ 6087
124++ 6087                  ; Tests a double register for a specific value.
125++ 6087                  ; E.g. TEST_REG hl, label1 ; Tests if register hl == label1
126++ 6087                  MACRO TEST_DREG dreg?, value?
127++ 6087 ~                    push de
128++ 6087 ~                    push hl
129++ 6087 ~                    push dreg?
130++ 6087 ~                    pop hl
131++ 6087 ~                    ld de,value?
132++ 6087 ~                    or a
133++ 6087 ~                    sbc hl,de
134++ 6087 ~                    pop hl
135++ 6087 ~                    pop de
136++ 6087 ~                    call nz,UNITTEST_TEST_READY_FAILURE ; de = (addr)
137++ 6087 ~                    nop
138++ 6087                  ENDM
139++ 6087
140++ 6087
141++ 6087                   ; Tests a double register for a specific value.
142++ 6087                  ; E.g. TEST_REG hl, label1 ; Tests if register hl == label1
143++ 6087                  MACRO TEST_DREG_UNEQUAL dreg?, value?
144++ 6087 ~                    push de
145++ 6087 ~                    push hl
146++ 6087 ~                    push dreg?
147++ 6087 ~                    pop hl
148++ 6087 ~                    ld de,value?
149++ 6087 ~                    or a
150++ 6087 ~                    sbc hl,de
151++ 6087 ~                    pop hl
152++ 6087 ~                    pop de
153++ 6087 ~                    call z,UNITTEST_TEST_READY_FAILURE ; de = (addr)
154++ 6087 ~                    nop
155++ 6087                  ENDM
156++ 6087
157++ 6087
158++ 6087                  ; Test two registers for equality.
159++ 6087                  ; Testcase fails if registers are not equal.
160++ 6087                  MACRO TEST_DREGS dreg1?, dreg2?
161++ 6087 ~                    push de
162++ 6087 ~                    push hl
163++ 6087 ~                    push dreg1?
164++ 6087 ~                    push dreg2?
165++ 6087 ~                    pop de
166++ 6087 ~                    pop hl
167++ 6087 ~                    or a
168++ 6087 ~                    sbc hl,de
169++ 6087 ~                    pop hl
170++ 6087 ~                    pop de
171++ 6087 ~                    call nz,UNITTEST_TEST_READY_FAILURE
172++ 6087 ~                    nop
173++ 6087                  ENDM
174++ 6087
175++ 6087
176++ 6087                  ; Test two registers for unequality.
177++ 6087                  ; Testcase fails if registers are equal.
178++ 6087                  MACRO TEST_DREGS_UNEQUAL dreg1?, dreg2?
179++ 6087 ~                    push de
180++ 6087 ~                    push hl
181++ 6087 ~                    push dreg1?
182++ 6087 ~                    push dreg2?
183++ 6087 ~                    pop de
184++ 6087 ~                    pop hl
185++ 6087 ~                    or a
186++ 6087 ~                    sbc hl,de
187++ 6087 ~                    pop hl
188++ 6087 ~                    pop de
189++ 6087 ~                    call z,UNITTEST_TEST_READY_FAILURE
190++ 6087 ~                    nop
191++ 6087                  ENDM
192++ 6087
193++ 6087
194++ 6087                  ; Compares 2 memory areas containing null terminated strings.
195++ 6087                  ; addr1 = the first string
196++ 6087                  ; addr2 = the second string
197++ 6087                  MACRO TEST_STRING_PTR addr1?, addr2?
198++ 6087 ~                    push af
199++ 6087 ~                    push hl
200++ 6087 ~                    push de
201++ 6087 ~                    ld de,addr2?
202++ 6087 ~                    ld hl,addr1?
203++ 6087 ~            .loop:
204++ 6087 ~                    ld a,(de)
205++ 6087 ~                    ; Check for null termination
206++ 6087 ~                    cp (hl)
207++ 6087 ~                    jr nz,.not_equal
208++ 6087 ~                    or a
209++ 6087 ~                    jr z,.null_found
210++ 6087 ~                    inc de
211++ 6087 ~                    inc hl
212++ 6087 ~                    jr .loop
213++ 6087 ~
214++ 6087 ~            .not_equal:
215++ 6087 ~                    ; Strings are not equal
216++ 6087 ~                    pop de
217++ 6087 ~                    pop hl
218++ 6087 ~                    pop af
219++ 6087 ~                    call UNITTEST_TEST_READY_FAILURE
220++ 6087 ~                    jr .end
221++ 6087 ~
222++ 6087 ~            .null_found:
223++ 6087 ~                    pop de
224++ 6087 ~                    pop hl
225++ 6087 ~                    pop af
226++ 6087 ~            .end:
227++ 6087                  ENDM
228++ 6087
229++ 6087
230++ 6087                  ; Tests a memory address for a specific string.
231++ 6087                  ; addr = the tested string
232++ 6087                  ; string = the compared string, e.g. "STRING"
233++ 6087                  ; term0 = If 0 it is also tested that the string (addr) is null terminated
234++ 6087                  MACRO TEST_STRING addr?, string?, term0?
235++ 6087 ~                    push af
236++ 6087 ~                    push hl
237++ 6087 ~                    push de
238++ 6087 ~                    ld de,.comp_string
239++ 6087 ~                    ld hl,addr?
240++ 6087 ~            .loop:
241++ 6087 ~                    ld a,(de)
242++ 6087 ~                    ; Check for null termination
243++ 6087 ~                    or a
244++ 6087 ~                    jr z,.null_found
245++ 6087 ~                    cp (hl)
246++ 6087 ~                    inc de
247++ 6087 ~                    inc hl
248++ 6087 ~                    jr z,.loop
249++ 6087 ~
250++ 6087 ~            .not_equal:
251++ 6087 ~                    ; Strings are not equal
252++ 6087 ~                    pop de
253++ 6087 ~                    pop hl
254++ 6087 ~                    pop af
255++ 6087 ~                    call UNITTEST_TEST_READY_FAILURE
256++ 6087 ~                    jr .end
257++ 6087 ~
258++ 6087 ~            .comp_string:
259++ 6087 ~                    defb string?, 0
260++ 6087 ~
261++ 6087 ~            .null_found:
262++ 6087 ~                    ; We are at the end of the compare string.
263++ 6087 ~                    ; Check if null termination should be compared with the tested string.
264++ 6087 ~                  IF term0? == 0
265++ 6087 ~                    cp (hl)
266++ 6087 ~                    jr nz,.not_equal
267++ 6087 ~                  ENDIF
268++ 6087 ~
269++ 6087 ~                    pop de
270++ 6087 ~                    pop hl
271++ 6087 ~                    pop af
272++ 6087 ~            .end:
273++ 6087                  ENDM
274++ 6087
275++ 6087
276++ 6087                  ; Tests a memory address for a specific string.
277++ 6087                  ; addr1 = the tested memory area
278++ 6087                  ; addr2 = the memory area to compare to
279++ 6087                  ; count = the number of elements to compare
280++ 6087                  MACRO TEST_MEM_CMP addr1?, addr2?, count?
281++ 6087 ~                    push af
282++ 6087 ~                    push hl
283++ 6087 ~                    push de
284++ 6087 ~                    push bc
285++ 6087 ~                    ld de,addr2?
286++ 6087 ~                    ld hl,addr1?
287++ 6087 ~                    ld bc,count?
288++ 6087 ~            .loop:
289++ 6087 ~                    ld a,(de)
290++ 6087 ~                    ; Compare
291++ 6087 ~                    cpi      ; cp (hl++); dec bc
292++ 6087 ~                    jr nz,.not_equal
293++ 6087 ~                    inc de
294++ 6087 ~                    jp pe,.loop
295++ 6087 ~
296++ 6087 ~                    ; Memory is equal
297++ 6087 ~                    pop bc
298++ 6087 ~                    pop de
299++ 6087 ~                    pop hl
300++ 6087 ~                    pop af
301++ 6087 ~                    jr .end
302++ 6087 ~
303++ 6087 ~            .not_equal:
304++ 6087 ~                    ; Memory areas are not equal
305++ 6087 ~                    pop bc
306++ 6087 ~                    pop de
307++ 6087 ~                    pop hl
308++ 6087 ~                    pop af
309++ 6087 ~                    call UNITTEST_TEST_READY_FAILURE
310++ 6087 ~                    jr .end
311++ 6087 ~            .end:
312++ 6087                  ENDM
313++ 6087
314++ 6087
315++ 6087                  ; Initializes the registers with default values.
316++ 6087                  ; Use before the tested function is called.
317++ 6087                  ; After the call the TEST_UNCHANGED_XX tests can be used
318++ 6087                  ; to check if the register was changed.
319++ 6087                  MACRO DEFAULT_REGS
320++ 6087 ~                    ld a,0xAA
321++ 6087 ~                    ld bc,0xBBCC
322++ 6087 ~                    ld de,0xDDEE
323++ 6087 ~                    ld hl,0x8899
324++ 6087                  ENDM
325++ 6087
326++ 6087                  MACRO TEST_UNCHANGED_BC
327++ 6087 ~                    push hl
328++ 6087 ~                    ld hl,0xBBCC
329++ 6087 ~                    or a
330++ 6087 ~                    sbc hl,bc
331++ 6087 ~                    pop hl
332++ 6087 ~                    call nz,UNITTEST_TEST_READY_FAILURE
333++ 6087 ~                    nop
334++ 6087                  ENDM
335++ 6087
336++ 6087                  MACRO TEST_UNCHANGED_DE
337++ 6087 ~                    push hl
338++ 6087 ~                    ld hl,0xDDEE
339++ 6087 ~                    or a
340++ 6087 ~                    sbc hl,de
341++ 6087 ~                    pop hl
342++ 6087 ~                    call nz,UNITTEST_TEST_READY_FAILURE
343++ 6087 ~                    nop
344++ 6087                  ENDM
345++ 6087
346++ 6087                  MACRO TEST_UNCHANGED_HL
347++ 6087 ~                    push de
348++ 6087 ~                    ld de,0x8899
349++ 6087 ~                    or a
350++ 6087 ~                    sbc hl,de
351++ 6087 ~                    add hl,de   ; restore hl without affecting the flags
352++ 6087 ~                    pop de
353++ 6087 ~                    call nz,UNITTEST_TEST_READY_FAILURE
354++ 6087 ~                    nop
355++ 6087                  ENDM
356++ 6087
357++ 6087                  MACRO TEST_UNCHANGED_BC_DE
358++ 6087 ~                    TEST_UNCHANGED_BC
359++ 6087 ~                    TEST_UNCHANGED_DE
360++ 6087                  ENDM
361++ 6087
362++ 6087                  MACRO TEST_UNCHANGED_BC_DE_HL
363++ 6087 ~                    TEST_UNCHANGED_BC_DE
364++ 6087 ~                    TEST_UNCHANGED_HL
365++ 6087                  ENDM
366++ 6087
367++ 6087                  MACRO TEST_UNCHANGED_A
368++ 6087 ~                    TEST_A 0xAA
369++ 6087                  ENDM
370++ 6087
371++ 6087                  MACRO TEST_UNCHANGED_B
372++ 6087 ~                    TEST_REG b, 0xBB
373++ 6087                  ENDM
374++ 6087
375++ 6087                  MACRO TEST_UNCHANGED_C
376++ 6087 ~                    TEST_REG c, 0xCC
377++ 6087                  ENDM
378++ 6087
379++ 6087                  MACRO TEST_UNCHANGED_D
380++ 6087 ~                    TEST_REG d, 0xDD
381++ 6087                  ENDM
382++ 6087
383++ 6087                  MACRO TEST_UNCHANGED_E
384++ 6087 ~                    TEST_REG e, 0xEE
385++ 6087                  ENDM
386++ 6087
387++ 6087                  MACRO TEST_UNCHANGED_H
388++ 6087 ~                    TEST_REG h, 0x88
389++ 6087                  ENDM
390++ 6087
391++ 6087                  MACRO TEST_UNCHANGED_L
392++ 6087 ~                    TEST_REG l, 0x99
393++ 6087                  ENDM
394++ 6087
395++ 6087
396++ 6087                  ; Macro to test flags for Z.
397++ 6087                  ; Testcase fails for NZ.
398++ 6087                  MACRO TEST_FLAG_Z
399++ 6087 ~                    call nz,UNITTEST_TEST_READY_FAILURE
400++ 6087 ~                    nop
401++ 6087                  ENDM
402++ 6087
403++ 6087
404++ 6087                  ; Macro to test flags for NZ.
405++ 6087                  ; Testcase fails for Z.
406++ 6087                  MACRO TEST_FLAG_NZ
407++ 6087 ~                    call z,UNITTEST_TEST_READY_FAILURE
408++ 6087 ~                    nop
409++ 6087                  ENDM
410++ 6087
411++ 6087
412++ 6087                  ; This macro uses all registers, also the shadow registers.
413++ 6087                  MACRO USE_ALL_REGS
414++ 6087 ~                    ld a,0xCD
415++ 6087 ~                    ld bc,0xBBCC
416++ 6087 ~                    ld de,0xDDEE
417++ 6087 ~                    ld hl,0xFF11
418++ 6087 ~                    ld ix,0x7788
419++ 6087 ~                    ld iy,0x99AA
420++ 6087 ~                    exx
421++ 6087 ~                   	ex af,af'
422++ 6087 ~                    ld a,0xDC
423++ 6087 ~                    ld bc,0x1122
424++ 6087 ~                    ld de,0x3344
425++ 6087 ~                    ld hl,0x5566
426++ 6087 ~                   	ex af,af'
427++ 6087 ~                    exx
428++ 6087                  ENDM
429++ 6087
430++ 6087                  ; This macro uses all registers with different values, also the shadow registers.
431++ 6087                  MACRO USE_ALL_REGS2
432++ 6087 ~                    ld a,0xC2
433++ 6087 ~                    ld bc,0xB2C2
434++ 6087 ~                    ld de,0xD2E2
435++ 6087 ~                    ld hl,0xF212
436++ 6087 ~                    ld ix,0x7282
437++ 6087 ~                    ld iy,0x92A2
438++ 6087 ~                    exx
439++ 6087 ~                   	ex af,af'
440++ 6087 ~                    ld a,0xD2
441++ 6087 ~                    ld bc,0x1223
442++ 6087 ~                    ld de,0x3242
443++ 6087 ~                    ld hl,0x5262
444++ 6087 ~                   	ex af,af'
445++ 6087 ~                    exx
446++ 6087                  ENDM
447++ 6087
448++ 6087                  ; sjasmplus end
449++ 6087                  ; -----------------------------------------------------------
450++ 6087
451++ 6087
452++ 6087                ELSE
453++ 6087 ~                ; -----------------------------------------------------------
454++ 6087 ~
455++ 6087 ~                ; -------------------------------------------------------
456++ 6087 ~                ; Code for e.g. Savannah's z80asm, maybe others.
457++ 6087 ~
458++ 6087 ~            UNITTEST_INITIALIZE:    MACRO
459++ 6087 ~
460++ 6087 ~                ; Called to call each unit test.
461++ 6087 ~            UNITTEST_TEST_WRAPPER:  di
462++ 6087 ~                    ld sp,UNITTEST_STACK
463++ 6087 ~            UNITTEST_CALL_ADDR: call 0x0000 ; Will be changed by the z80 unit tests.
464++ 6087 ~                    nop
465++ 6087 ~
466++ 6087 ~            UNITTEST_TEST_READY_RETURN_FAILURE: jr UNITTEST_TEST_READY_RETURN_FAILURE	; A breakpoint will be set here. The unit test will normally not return here but at UNITTEST_TEST_READY_SUCCESS
467++ 6087 ~
468++ 6087 ~            UNITTEST_TEST_READY_FAILURE:    nop
469++ 6087 ~            UNITTEST_TEST_READY_FAILURE_BREAKPOINT: ret 	; A breakpoint will be set here. The next step will return to the failed test case
470++ 6087 ~
471++ 6087 ~            UNITTEST_TEST_READY_SUCCESS:    jr UNITTEST_TEST_READY_SUCCESS	; A breakpoint will be set here.
472++ 6087 ~
473++ 6087 ~
474++ 6087 ~            UNITTEST_MIN_STACK_GUARD:   defw 0	; A write watchpoint will be set here to guard the stack
475++ 6087 ~                    defs 2*50	; Stack depth of 50 should be enough
476++ 6087 ~            UNITTEST_STACK: defw 0
477++ 6087 ~            UNITTEST_MAX_STACK_GUARD:   defw 0	; A write watchpoint will be set here to guard the stack
478++ 6087 ~
479++ 6087 ~            UNITTEST_SAVE_REG:  defw 0  ; Used to save register values.
480++ 6087 ~
481++ 6087 ~
482++ 6087 ~                ; The unit test initialization. Provided by the user.
483++ 6087 ~            UNITTEST_START: di       ; Disable interrupts
484++ 6087 ~                    ; Flow through.
485++ 6087 ~                    ; Directly after the UNITTEST_INITIALIZE macro the user
486++ 6087 ~                    ; should put his test initialization code.
487++ 6087 ~                    ; Note: the stack pointer does not need to be set up.
488++ 6087 ~
489++ 6087 ~                ENDM
490++ 6087 ~
491++ 6087 ~
492++ 6087 ~                ; Macro that must be used at the end of the test case (instead of a ret).
493++ 6087 ~            TC_END:    MACRO
494++ 6087 ~                    jp UNITTEST_TEST_READY_SUCCESS
495++ 6087 ~                ENDM
496++ 6087 ~
497++ 6087 ~
498++ 6087 ~
499++ 6087 ~                ; Tests a memory address for a specific byte value.
500++ 6087 ~            TEST_MEMORY_BYTE:    MACRO addr value
501++ 6087 ~                    ld (UNITTEST_SAVE_REG),a
502++ 6087 ~                    ld a,(addr)
503++ 6087 ~                    cp value
504++ 6087 ~                    call nz,UNITTEST_TEST_READY_FAILURE
505++ 6087 ~                    ld a,(UNITTEST_SAVE_REG)
506++ 6087 ~                ENDM
507++ 6087 ~
508++ 6087 ~                ; Tests a memory address for a specific word value.
509++ 6087 ~                ; If the test fails the '(addr)' can be found in DE.
510++ 6087 ~            TEST_MEMORY_WORD:    MACRO addr value
511++ 6087 ~                    push de
512++ 6087 ~                    push hl
513++ 6087 ~                    ld hl,value
514++ 6087 ~                    ld de,(addr)
515++ 6087 ~                    or a
516++ 6087 ~                    sbc hl,de
517++ 6087 ~                    pop hl
518++ 6087 ~                    call nz,UNITTEST_TEST_READY_FAILURE ; de = (addr)
519++ 6087 ~                    pop de
520++ 6087 ~                ENDM
521++ 6087 ~
522++ 6087 ~               ; Creates a failure when reached.
523++ 6087 ~            TEST_FAIL:  MACRO
524++ 6087 ~                    call UNITTEST_TEST_READY_FAILURE
525++ 6087 ~                ENDM
526++ 6087 ~
527++ 6087 ~                ; Tests A for a specific value.
528++ 6087 ~            TEST_A:    MACRO value
529++ 6087 ~                    cp value
530++ 6087 ~                    call nz,UNITTEST_TEST_READY_FAILURE
531++ 6087 ~                    nop
532++ 6087 ~                ENDM
533++ 6087 ~
534++ 6087 ~                ; Tests that A is not equal to a specific value.
535++ 6087 ~            TEST_A_UNEQUAL:    MACRO value
536++ 6087 ~                    cp value
537++ 6087 ~                    call z,UNITTEST_TEST_READY_FAILURE
538++ 6087 ~                    nop
539++ 6087 ~                ENDM
540++ 6087 ~
541++ 6087 ~                ; Tests a single register for a specific value.
542++ 6087 ~                ; E.g. TEST_REG b, 6 ; Tests if register b == 6
543++ 6087 ~            TEST_REG:    MACRO reg value
544++ 6087 ~                    ld (UNITTEST_SAVE_REG),a
545++ 6087 ~                    ld a,reg
546++ 6087 ~                    cp value
547++ 6087 ~                    call nz,UNITTEST_TEST_READY_FAILURE
548++ 6087 ~                    ld a,(UNITTEST_SAVE_REG)
549++ 6087 ~                ENDM
550++ 6087 ~
551++ 6087 ~                ; Tests that a single register is not a specific value.
552++ 6087 ~                ; E.g. TEST_REG_UNEQUAL b, 6 ; Tests if register b != 6
553++ 6087 ~            TEST_REG_UNEQUAL:    MACRO reg value
554++ 6087 ~                    ld (UNITTEST_SAVE_REG),a
555++ 6087 ~                    ld a,reg
556++ 6087 ~                    cp value
557++ 6087 ~                    call z,UNITTEST_TEST_READY_FAILURE
558++ 6087 ~                    ld a,(UNITTEST_SAVE_REG)
559++ 6087 ~                ENDM
560++ 6087 ~
561++ 6087 ~                ; Tests a double register for a specific value.
562++ 6087 ~                ; E.g. TEST_DREG hl, label1 ; Tests if register hl == label1
563++ 6087 ~            TEST_DREG:    MACRO dreg value
564++ 6087 ~                    push de
565++ 6087 ~                    push hl
566++ 6087 ~                    push dreg
567++ 6087 ~                    pop hl
568++ 6087 ~                    ld de,value
569++ 6087 ~                    or a
570++ 6087 ~                    sbc hl,de
571++ 6087 ~                    pop hl
572++ 6087 ~                    pop de
573++ 6087 ~                    call nz,UNITTEST_TEST_READY_FAILURE
574++ 6087 ~                    nop
575++ 6087 ~                ENDM
576++ 6087 ~
577++ 6087 ~                ; Tests a double register is not a specific value.
578++ 6087 ~                ; E.g. TEST_DREG_UNEQUAL hl, label1 ; Tests if register hl != label1
579++ 6087 ~            TEST_DREG_UNEQUAL:    MACRO dreg value
580++ 6087 ~                    push de
581++ 6087 ~                    push hl
582++ 6087 ~                    push dreg
583++ 6087 ~                    pop hl
584++ 6087 ~                    ld de,value
585++ 6087 ~                    or a
586++ 6087 ~                    sbc hl,de
587++ 6087 ~                    pop hl
588++ 6087 ~                    pop de
589++ 6087 ~                    call z,UNITTEST_TEST_READY_FAILURE
590++ 6087 ~                    nop
591++ 6087 ~                ENDM
592++ 6087 ~
593++ 6087 ~
594++ 6087 ~                ; Test two registers for equality.
595++ 6087 ~                ; Testcase fails if registers are not equal.
596++ 6087 ~            TEST_DREGS:    MACRO dreg1 dreg2
597++ 6087 ~                    push de
598++ 6087 ~                    push hl
599++ 6087 ~                    push dreg1
600++ 6087 ~                    push dreg2
601++ 6087 ~                    pop de
602++ 6087 ~                    pop hl
603++ 6087 ~                    or a
604++ 6087 ~                    sbc hl,de
605++ 6087 ~                    pop de
606++ 6087 ~                    pop hl
607++ 6087 ~                    call nz,UNITTEST_TEST_READY_FAILURE
608++ 6087 ~                    nop
609++ 6087 ~                ENDM
610++ 6087 ~
611++ 6087 ~
612++ 6087 ~                ; Test two registers for unequality.
613++ 6087 ~                ; Testcase fails if registers are equal.
614++ 6087 ~            TEST_DREGS_UNEQUAL:    MACRO dreg1 dreg2
615++ 6087 ~                    push de
616++ 6087 ~                    push hl
617++ 6087 ~                    push dreg1
618++ 6087 ~                    push dreg2
619++ 6087 ~                    pop de
620++ 6087 ~                    pop hl
621++ 6087 ~                    or a
622++ 6087 ~                    sbc hl,de
623++ 6087 ~                    pop de
624++ 6087 ~                    pop hl
625++ 6087 ~                    call z,UNITTEST_TEST_READY_FAILURE
626++ 6087 ~                    nop
627++ 6087 ~                ENDM
628++ 6087 ~
629++ 6087 ~                ; Compares 2 memory areas containing null terminated strings.
630++ 6087 ~                ; addr1 = the first string
631++ 6087 ~                ; addr2 = the second string
632++ 6087 ~            TEST_STRING_PTR:    MACRO addr1, addr2
633++ 6087 ~                    push af
634++ 6087 ~                    push hl
635++ 6087 ~                    push de
636++ 6087 ~                    ld de,addr2
637++ 6087 ~                    ld hl,addr1?
638++ 6087 ~            .loop:
639++ 6087 ~                    ld a,(de)
640++ 6087 ~                    ; Check for null termination
641++ 6087 ~                    cp (hl)
642++ 6087 ~                    jr nz,.not_equal
643++ 6087 ~                    or a
644++ 6087 ~                    jr z,.null_found
645++ 6087 ~                    inc de
646++ 6087 ~                    inc hl
647++ 6087 ~                    jr .loop
648++ 6087 ~
649++ 6087 ~            .not_equal:
650++ 6087 ~                    ; Strings are not equal
651++ 6087 ~                    pop de
652++ 6087 ~                    pop hl
653++ 6087 ~                    pop af
654++ 6087 ~                    call UNITTEST_TEST_READY_FAILURE
655++ 6087 ~                    jr .end
656++ 6087 ~
657++ 6087 ~            .null_found:
658++ 6087 ~                    pop de
659++ 6087 ~                    pop hl
660++ 6087 ~                    pop af
661++ 6087 ~            .end:
662++ 6087 ~                ENDM
663++ 6087 ~
664++ 6087 ~
665++ 6087 ~                ; Tests a memory address for a specific string.
666++ 6087 ~                ; addr = the tested string
667++ 6087 ~                ; string = the compared string
668++ 6087 ~                ; term0 = If 0 it is also tested that the string (addr) is null terminated
669++ 6087 ~            TEST_STRING:    MACRO addr string term0
670++ 6087 ~                    push af
671++ 6087 ~                    push hl
672++ 6087 ~                    push de
673++ 6087 ~                    ld de,.comp_string
674++ 6087 ~                    ld hl,addr?
675++ 6087 ~            .loop:
676++ 6087 ~                    ld a,(de)
677++ 6087 ~                    ; Check for null termination
678++ 6087 ~                    or a
679++ 6087 ~                    jr z,.null_found
680++ 6087 ~                    cp (hl)
681++ 6087 ~                    inc de
682++ 6087 ~                    inc hl
683++ 6087 ~                    jr z,.loop
684++ 6087 ~
685++ 6087 ~            .not_equal:
686++ 6087 ~                    ; Strings are not equal
687++ 6087 ~                    pop de
688++ 6087 ~                    pop hl
689++ 6087 ~                    pop af
690++ 6087 ~                    call UNITTEST_TEST_READY_FAILURE
691++ 6087 ~                    jr .end
692++ 6087 ~
693++ 6087 ~            .comp_string:
694++ 6087 ~                    defb string, 0
695++ 6087 ~
696++ 6087 ~            .null_found:
697++ 6087 ~                    ; We are at the end of the compare string.
698++ 6087 ~                    ; Check if null termination should be compared with the tested string.
699++ 6087 ~                  IF term0 == 0
700++ 6087 ~                    cp (hl)
701++ 6087 ~                    jr nz,.not_equal
702++ 6087 ~                  ENDIF
703++ 6087 ~
704++ 6087 ~                    pop de
705++ 6087 ~                    pop hl
706++ 6087 ~                    pop af
707++ 6087 ~            .end:
708++ 6087 ~                ENDM
709++ 6087 ~
710++ 6087 ~
711++ 6087 ~                ; Tests a memory address for a specific string.
712++ 6087 ~                ; addr1 = the tested memory area
713++ 6087 ~                ; addr2 = the memory area to compare to
714++ 6087 ~                ; count = the number of elements to compare
715++ 6087 ~            TEST_MEM_CMP:   MACRO addr1, addr2, count
716++ 6087 ~                    push af
717++ 6087 ~                    push hl
718++ 6087 ~                    push de
719++ 6087 ~                    push bc
720++ 6087 ~                    ld de,addr2
721++ 6087 ~                    ld hl,addr1
722++ 6087 ~                    ld bc,count
723++ 6087 ~            .loop:
724++ 6087 ~                    ld a,(de)
725++ 6087 ~                    ; Compare
726++ 6087 ~                    cpi      ; cp (hl++); dec bc
727++ 6087 ~                    jr nz,.not_equal
728++ 6087 ~                    inc de
729++ 6087 ~                    jp pe,.loop
730++ 6087 ~
731++ 6087 ~                    ; Memory is equal
732++ 6087 ~                    pop bc
733++ 6087 ~                    pop de
734++ 6087 ~                    pop hl
735++ 6087 ~                    pop af
736++ 6087 ~                    jr .end
737++ 6087 ~
738++ 6087 ~            .not_equal:
739++ 6087 ~                    ; Memory areas are not equal
740++ 6087 ~                    pop bc
741++ 6087 ~                    pop de
742++ 6087 ~                    pop hl
743++ 6087 ~                    pop af
744++ 6087 ~                    call UNITTEST_TEST_READY_FAILURE
745++ 6087 ~                    jr .end
746++ 6087 ~            .end:
747++ 6087 ~                ENDM
748++ 6087 ~
749++ 6087 ~
750++ 6087 ~                ; Initializes the registers with default values.
751++ 6087 ~                ; Use before the tested function is called.
752++ 6087 ~                ; After the call the TEST_UNCHANGED_XX tests can be used
753++ 6087 ~                ; to check if the register was changed.
754++ 6087 ~            DEFAULT_REGS:    MACRO
755++ 6087 ~                    ld a,0xAA
756++ 6087 ~                    ld bc,0xBBCC
757++ 6087 ~                    ld de,0xDDEE
758++ 6087 ~                    ld hl,0x8899
759++ 6087 ~                ENDM
760++ 6087 ~
761++ 6087 ~            TEST_UNCHANGED_BC:    MACRO
762++ 6087 ~                    push hl
763++ 6087 ~                    ld hl,0xBBCC
764++ 6087 ~                    or a
765++ 6087 ~                    sbc hl,bc
766++ 6087 ~                    pop hl
767++ 6087 ~                    call nz,UNITTEST_TEST_READY_FAILURE
768++ 6087 ~                    nop
769++ 6087 ~                ENDM
770++ 6087 ~
771++ 6087 ~            TEST_UNCHANGED_DE:    MACRO
772++ 6087 ~                    push hl
773++ 6087 ~                    ld hl,0xDDEE
774++ 6087 ~                    or a
775++ 6087 ~                    sbc hl,de
776++ 6087 ~                    pop hl
777++ 6087 ~                    call nz,UNITTEST_TEST_READY_FAILURE
778++ 6087 ~                    nop
779++ 6087 ~                ENDM
780++ 6087 ~
781++ 6087 ~            TEST_UNCHANGED_HL:    MACRO
782++ 6087 ~                    push de
783++ 6087 ~                    ld de,0x8899
784++ 6087 ~                    or a
785++ 6087 ~                    sbc hl,de
786++ 6087 ~                    add hl,de   ; restore hl without affecting the flags
787++ 6087 ~                    pop de
788++ 6087 ~                    call nz,UNITTEST_TEST_READY_FAILURE
789++ 6087 ~                    nop
790++ 6087 ~                ENDM
791++ 6087 ~
792++ 6087 ~            TEST_UNCHANGED_BC_DE:    MACRO
793++ 6087 ~                    TEST_UNCHANGED_BC
794++ 6087 ~                    TEST_UNCHANGED_DE
795++ 6087 ~                ENDM
796++ 6087 ~
797++ 6087 ~            TEST_UNCHANGED_BC_DE_HL:    MACRO
798++ 6087 ~                    TEST_UNCHANGED_BC_DE
799++ 6087 ~                    TEST_UNCHANGED_HL
800++ 6087 ~                ENDM
801++ 6087 ~
802++ 6087 ~            TEST_UNCHANGED_A:    MACRO
803++ 6087 ~                    TEST_A 0xAA
804++ 6087 ~                ENDM
805++ 6087 ~
806++ 6087 ~            TEST_UNCHANGED_B:    MACRO
807++ 6087 ~                    TEST_REG b, 0xBB
808++ 6087 ~                ENDM
809++ 6087 ~
810++ 6087 ~            TEST_UNCHANGED_C:    MACRO
811++ 6087 ~                    TEST_REG c, 0xCC
812++ 6087 ~                ENDM
813++ 6087 ~
814++ 6087 ~            TEST_UNCHANGED_D:    MACRO
815++ 6087 ~                    TEST_REG d, 0xDD
816++ 6087 ~                ENDM
817++ 6087 ~
818++ 6087 ~            TEST_UNCHANGED_E:    MACRO
819++ 6087 ~                    TEST_REG e, 0xEE
820++ 6087 ~                ENDM
821++ 6087 ~
822++ 6087 ~            TEST_UNCHANGED_H:    MACRO
823++ 6087 ~                    TEST_REG h, 0x88
824++ 6087 ~                ENDM
825++ 6087 ~
826++ 6087 ~            TEST_UNCHANGED_L:    MACRO
827++ 6087 ~                    TEST_REG l, 0x99
828++ 6087 ~                ENDM
829++ 6087 ~
830++ 6087 ~
831++ 6087 ~                ; Macro to test flags for Z.
832++ 6087 ~                ; Testcase fails for NZ.
833++ 6087 ~            TEST_FLAG_Z:    MACRO
834++ 6087 ~                    call nz,UNITTEST_TEST_READY_FAILURE
835++ 6087 ~                    nop
836++ 6087 ~                ENDM
837++ 6087 ~
838++ 6087 ~
839++ 6087 ~                ; Macro to test flags for NZ.
840++ 6087 ~                ; Testcase fails for Z.
841++ 6087 ~            TEST_FLAG_NZ:    MACRO
842++ 6087 ~                    call z,UNITTEST_TEST_READY_FAILURE
843++ 6087 ~                    nop
844++ 6087 ~                ENDM
845++ 6087 ~
846++ 6087 ~
847++ 6087 ~                ; This macro uses all registers, also the shadow registers.
848++ 6087 ~            USE_ALL_REGS:    MACRO
849++ 6087 ~                    ld a,0xCD
850++ 6087 ~                    ld bc,0xBBCC
851++ 6087 ~                    ld de,0xDDEE
852++ 6087 ~                    ld hl,0xFF11
853++ 6087 ~                    ld ix,0x7788
854++ 6087 ~                    ld iy,0x99AA
855++ 6087 ~                    exx
856++ 6087 ~                   	ex af,af'
857++ 6087 ~                    ld a,0xDC
858++ 6087 ~                    ld bc,0x1122
859++ 6087 ~                    ld de,0x3344
860++ 6087 ~                    ld hl,0x5566
861++ 6087 ~                   	ex af,af'
862++ 6087 ~                    exx
863++ 6087 ~                ENDM
864++ 6087 ~
865++ 6087 ~                ; This macro uses all registers with different values, also the shadow registers.
866++ 6087 ~            USE_ALL_REGS2:  MACRO
867++ 6087 ~                    ld a,0xC2
868++ 6087 ~                    ld bc,0xB2C2
869++ 6087 ~                    ld de,0xD2E2
870++ 6087 ~                    ld hl,0xF212
871++ 6087 ~                    ld ix,0x7282
872++ 6087 ~                    ld iy,0x92A2
873++ 6087 ~                    exx
874++ 6087 ~                   	ex af,af'
875++ 6087 ~                    ld a,0xD2
876++ 6087 ~                    ld bc,0x1223
877++ 6087 ~                    ld de,0x3242
878++ 6087 ~                    ld hl,0x5262
879++ 6087 ~                   	ex af,af'
880++ 6087 ~                    exx
881++ 6087 ~                ENDM
882++ 6087 ~
883++ 6087 ~
884++ 6087 ~                ; other assemblers end
885++ 6087 ~                ; -----------------------------------------------------------
886++ 6087                ENDIF
887++ 6087
# file closed: unit_tests.inc
  8+  6087
  9+  6087
 10+  6087              ; Initialization routine called before all unit tests are
 11+  6087              ; started.
 12+  6087                  UNITTEST_INITIALIZE
 12+  6087             >
 12+  6087             >    ; Called to call each unit test.
 12+  6087             >@UNITTEST_TEST_WRAPPER:
 12+  6087 F3          >        di
 12+  6088 31 FB 60    >        ld sp,UNITTEST_STACK
 12+  608B             >@UNITTEST_CALL_ADDR:
 12+  608B CD 00 00    >        call 0x0000 ; Will be changed by the z80 unit tests.
 12+  608E 00          >        nop
 12+  608F             >
 12+  608F             >@UNITTEST_TEST_READY_RETURN_FAILURE:
 12+  608F 18 FE       >        jr UNITTEST_TEST_READY_RETURN_FAILURE	; A breakpoint will be set here. The unit test will normally not return here but at UNITTEST_TEST_READY_SUCCESS
 12+  6091             >
 12+  6091             >@UNITTEST_TEST_READY_FAILURE:
 12+  6091 00          >        nop
 12+  6092             >@UNITTEST_TEST_READY_FAILURE_BREAKPOINT:
 12+  6092 C9          >        ret 	; A breakpoint will be set here. The next step will return to the failed test case
 12+  6093             >
 12+  6093             >@UNITTEST_TEST_READY_SUCCESS:
 12+  6093 18 FE       >        jr UNITTEST_TEST_READY_SUCCESS	; A breakpoint will be set here.
 12+  6095             >
 12+  6095             >@UNITTEST_MIN_STACK_GUARD:
 12+  6095 00 00       >        defw 0	; A write watchpoint will be set here to guard the stack
 12+  6097 00 00 00... >        defs 2*50	; Stack depth of 50 should be enough
 12+  60FB             >@UNITTEST_STACK:
 12+  60FB             >
 12+  60FB             >@UNITTEST_MAX_STACK_GUARD:
 12+  60FB 00 00       >        defw 0	; A write watchpoint will be set here to guard the stack
 12+  60FD             >
 12+  60FD             >@UNITTEST_SAVE_REG:
 12+  60FD 00 00       >        defw 0  ; Used to save register values.
 12+  60FF             >
 12+  60FF             >
 12+  60FF             >    ; The unit test initialization. Provided by the user.
 12+  60FF             >@UNITTEST_START:
 12+  60FF             >        ; Disable interrupts
 12+  60FF F3          >        di
 12+  6100             >        ; Flow through.
 12+  6100             >        ; Directly after the UNITTEST_INITIALIZE macro the user
 12+  6100             >        ; should put his test initialization code.
 12+  6100             >        ; Note: the stack pointer does not need to be set up.
 12+  6100             >
 13+  6100                  ; Do your initialization here ...
 14+  6100                  ; ...
 15+  6100                  ; ...
 16+  6100                  ; For this simple example we don't need any special initialization.
 17+  6100                  ; So we simply return.
 18+  6100                  ; Please note: the stack pointer does not need to be setup explicitly
 19+  6100                  ; for the unit tests.
 20+  6100 C9               ret
 21+  6101
 22+  6101
 23+  6101                  MODULE TestSuite_ClearScreen
 24+  6101
 25+  6101              ; A unit testcase needs to start with "UT_" (upper case letters).
 26+  6101              ; DeZog will collect all these labels and offer them for execution.
 27+  6101              UT_clear_screen:
 28+  6101                  ; Write some bytes to the screen area
 29+  6101 3E FF            ld a,0xFF
 30+  6103 32 00 40         ld (SCREEN),a
 31+  6106 32 00 4C         ld (SCREEN+SCREEN_SIZE/2),a
 32+  6109 32 FF 57         ld (SCREEN+SCREEN_SIZE-1),a
 33+  610C 32 00 58         ld (SCREEN+SCREEN_SIZE),a
 34+  610F
 35+  610F                  ; Now clear the screen
 36+  610F CD 47 60         call clear_screen
 37+  6112
 38+  6112                  ; Test that all values inside the screen area are cleared
 39+  6112                  TEST_MEMORY_BYTE SCREEN, 0
 39+  6112 32 FD 60    >        ld (UNITTEST_SAVE_REG),a
 39+  6115 3A 00 40    >        ld a,(SCREEN)
 39+  6118 FE 00       >        cp 0
 39+  611A C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE
 39+  611D 3A FD 60    >        ld a,(UNITTEST_SAVE_REG)
 40+  6120                  TEST_MEMORY_BYTE SCREEN+SCREEN_SIZE/2, 0
 40+  6120 32 FD 60    >        ld (UNITTEST_SAVE_REG),a
 40+  6123 3A 00 4C    >        ld a,(SCREEN+SCREEN_SIZE/2)
 40+  6126 FE 00       >        cp 0
 40+  6128 C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE
 40+  612B 3A FD 60    >        ld a,(UNITTEST_SAVE_REG)
 41+  612E                  TEST_MEMORY_BYTE SCREEN+SCREEN_SIZE-1, 0
 41+  612E 32 FD 60    >        ld (UNITTEST_SAVE_REG),a
 41+  6131 3A FF 57    >        ld a,(SCREEN+SCREEN_SIZE-1)
 41+  6134 FE 00       >        cp 0
 41+  6136 C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE
 41+  6139 3A FD 60    >        ld a,(UNITTEST_SAVE_REG)
 42+  613C
 43+  613C                  TEST_MEMORY_BYTE SCREEN+SCREEN_SIZE, 0xFF
 43+  613C 32 FD 60    >        ld (UNITTEST_SAVE_REG),a
 43+  613F 3A 00 58    >        ld a,(SCREEN+SCREEN_SIZE)
 43+  6142 FE FF       >        cp 0xFF
 43+  6144 C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE
 43+  6147 3A FD 60    >        ld a,(UNITTEST_SAVE_REG)
 44+  614A               TC_END
 44+  614A C3 93 60    >        jp UNITTEST_TEST_READY_SUCCESS
 45+  614D
 46+  614D
 47+  614D              ; Tests filling the background.
 48+  614D              UT_fill_backg:
 49+  614D                  ; Write some bytes to the screen area
 50+  614D 3E FF            ld a,0xFF
 51+  614F 32 00 58         ld (COLOR_SCREEN),a
 52+  6152 32 80 59         ld (COLOR_SCREEN+COLOR_SCREEN_SIZE/2),a
 53+  6155 32 FF 5A         ld (COLOR_SCREEN+COLOR_SCREEN_SIZE-1),a
 54+  6158 32 00 5B         ld (COLOR_SCREEN+COLOR_SCREEN_SIZE),a
 55+  615B
 56+  615B                  ; Now fill the background with 128
 57+  615B 3E 80            ld a,128
 58+  615D CD 57 60         call fill_backg
 59+  6160
 60+  6160                  ; Test that all values inside the screen area are cleared
 61+  6160                  TEST_MEMORY_BYTE COLOR_SCREEN, 128
 61+  6160 32 FD 60    >        ld (UNITTEST_SAVE_REG),a
 61+  6163 3A 00 58    >        ld a,(COLOR_SCREEN)
 61+  6166 FE 80       >        cp 128
 61+  6168 C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE
 61+  616B 3A FD 60    >        ld a,(UNITTEST_SAVE_REG)
 62+  616E                  TEST_MEMORY_BYTE COLOR_SCREEN+COLOR_SCREEN_SIZE/2, 128
 62+  616E 32 FD 60    >        ld (UNITTEST_SAVE_REG),a
 62+  6171 3A 80 59    >        ld a,(COLOR_SCREEN+COLOR_SCREEN_SIZE/2)
 62+  6174 FE 80       >        cp 128
 62+  6176 C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE
 62+  6179 3A FD 60    >        ld a,(UNITTEST_SAVE_REG)
 63+  617C                  TEST_MEMORY_BYTE COLOR_SCREEN+COLOR_SCREEN_SIZE-1, 128
 63+  617C 32 FD 60    >        ld (UNITTEST_SAVE_REG),a
 63+  617F 3A FF 5A    >        ld a,(COLOR_SCREEN+COLOR_SCREEN_SIZE-1)
 63+  6182 FE 80       >        cp 128
 63+  6184 C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE
 63+  6187 3A FD 60    >        ld a,(UNITTEST_SAVE_REG)
 64+  618A
 65+  618A                  TEST_MEMORY_BYTE COLOR_SCREEN+COLOR_SCREEN_SIZE, 0xFF
 65+  618A 32 FD 60    >        ld (UNITTEST_SAVE_REG),a
 65+  618D 3A 00 5B    >        ld a,(COLOR_SCREEN+COLOR_SCREEN_SIZE)
 65+  6190 FE FF       >        cp 0xFF
 65+  6192 C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE
 65+  6195 3A FD 60    >        ld a,(UNITTEST_SAVE_REG)
 66+  6198               TC_END
 66+  6198 C3 93 60    >        jp UNITTEST_TEST_READY_SUCCESS
 67+  619B
 68+  619B
 69+  619B              ; Tests clearing the background.
 70+  619B              UT_clear_backg:
 71+  619B                  ; Write some bytes to the screen area
 72+  619B 3E FF            ld a,0xFF
 73+  619D 32 00 58         ld (COLOR_SCREEN),a
 74+  61A0 32 80 59         ld (COLOR_SCREEN+COLOR_SCREEN_SIZE/2),a
 75+  61A3 32 FF 5A         ld (COLOR_SCREEN+COLOR_SCREEN_SIZE-1),a
 76+  61A6 32 00 5B         ld (COLOR_SCREEN+COLOR_SCREEN_SIZE),a
 77+  61A9
 78+  61A9                  ; Now clear the background
 79+  61A9 CD 52 60         call clear_backg
 80+  61AC
 81+  61AC                  ; Test that all values inside the screen area are cleared
 82+  61AC                  TEST_MEMORY_BYTE COLOR_SCREEN, 0
 82+  61AC 32 FD 60    >        ld (UNITTEST_SAVE_REG),a
 82+  61AF 3A 00 58    >        ld a,(COLOR_SCREEN)
 82+  61B2 FE 00       >        cp 0
 82+  61B4 C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE
 82+  61B7 3A FD 60    >        ld a,(UNITTEST_SAVE_REG)
 83+  61BA                  TEST_MEMORY_BYTE COLOR_SCREEN+COLOR_SCREEN_SIZE/2, 0
 83+  61BA 32 FD 60    >        ld (UNITTEST_SAVE_REG),a
 83+  61BD 3A 80 59    >        ld a,(COLOR_SCREEN+COLOR_SCREEN_SIZE/2)
 83+  61C0 FE 00       >        cp 0
 83+  61C2 C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE
 83+  61C5 3A FD 60    >        ld a,(UNITTEST_SAVE_REG)
 84+  61C8                  TEST_MEMORY_BYTE COLOR_SCREEN+COLOR_SCREEN_SIZE-1, 0
 84+  61C8 32 FD 60    >        ld (UNITTEST_SAVE_REG),a
 84+  61CB 3A FF 5A    >        ld a,(COLOR_SCREEN+COLOR_SCREEN_SIZE-1)
 84+  61CE FE 00       >        cp 0
 84+  61D0 C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE
 84+  61D3 3A FD 60    >        ld a,(UNITTEST_SAVE_REG)
 85+  61D6
 86+  61D6                  TEST_MEMORY_BYTE COLOR_SCREEN+COLOR_SCREEN_SIZE, 0xFF
 86+  61D6 32 FD 60    >        ld (UNITTEST_SAVE_REG),a
 86+  61D9 3A 00 5B    >        ld a,(COLOR_SCREEN+COLOR_SCREEN_SIZE)
 86+  61DC FE FF       >        cp 0xFF
 86+  61DE C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE
 86+  61E1 3A FD 60    >        ld a,(UNITTEST_SAVE_REG)
 87+  61E4               TC_END
 87+  61E4 C3 93 60    >        jp UNITTEST_TEST_READY_SUCCESS
 88+  61E7
 89+  61E7                  ENDMODULE
 90+  61E7
 91+  61E7
 92+  61E7
 93+  61E7                  MODULE TestSuite_Fill
 94+  61E7
 95+  61E7              ; Tests filling a memory area
 96+  61E7              UT_fill_memory:
 97+  61E7                  ; Write some bytes
 98+  61E7 3E FF            ld a,0xFF
 99+  61E9 32 4C 62         ld (fill_memory_data-1),a
100+  61EC 32 4D 62         ld (fill_memory_data),a
101+  61EF 32 52 62         ld (fill_memory_data+FILL_MEMORY_SIZE/2),a
102+  61F2 32 56 62         ld (fill_memory_data+FILL_MEMORY_SIZE-1),a
103+  61F5 32 57 62         ld (fill_memory_data+FILL_MEMORY_SIZE),a
104+  61F8
105+  61F8                  ; Now fill the memory area
106+  61F8 3E 16            ld a,22
107+  61FA 21 4D 62         ld hl,fill_memory_data
108+  61FD 01 0A 00         ld bc,FILL_MEMORY_SIZE
109+  6200 CD 0F 60         call fill_memory
110+  6203
111+  6203                  ; Test that all values inside the screen area are cleared
112+  6203                  TEST_MEMORY_BYTE fill_memory_data-1, 0xFF
112+  6203 32 FD 60    >        ld (UNITTEST_SAVE_REG),a
112+  6206 3A 4C 62    >        ld a,(fill_memory_data-1)
112+  6209 FE FF       >        cp 0xFF
112+  620B C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE
112+  620E 3A FD 60    >        ld a,(UNITTEST_SAVE_REG)
113+  6211                  TEST_MEMORY_BYTE fill_memory_data, 22
113+  6211 32 FD 60    >        ld (UNITTEST_SAVE_REG),a
113+  6214 3A 4D 62    >        ld a,(fill_memory_data)
113+  6217 FE 16       >        cp 22
113+  6219 C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE
113+  621C 3A FD 60    >        ld a,(UNITTEST_SAVE_REG)
114+  621F                  TEST_MEMORY_BYTE fill_memory_data+FILL_MEMORY_SIZE/2, 22
114+  621F 32 FD 60    >        ld (UNITTEST_SAVE_REG),a
114+  6222 3A 52 62    >        ld a,(fill_memory_data+FILL_MEMORY_SIZE/2)
114+  6225 FE 16       >        cp 22
114+  6227 C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE
114+  622A 3A FD 60    >        ld a,(UNITTEST_SAVE_REG)
115+  622D                  TEST_MEMORY_BYTE fill_memory_data+FILL_MEMORY_SIZE-1, 22
115+  622D 32 FD 60    >        ld (UNITTEST_SAVE_REG),a
115+  6230 3A 56 62    >        ld a,(fill_memory_data+FILL_MEMORY_SIZE-1)
115+  6233 FE 16       >        cp 22
115+  6235 C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE
115+  6238 3A FD 60    >        ld a,(UNITTEST_SAVE_REG)
116+  623B
117+  623B                  TEST_MEMORY_BYTE fill_memory_data+FILL_MEMORY_SIZE, 0xFF
117+  623B 32 FD 60    >        ld (UNITTEST_SAVE_REG),a
117+  623E 3A 57 62    >        ld a,(fill_memory_data+FILL_MEMORY_SIZE)
117+  6241 FE FF       >        cp 0xFF
117+  6243 C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE
117+  6246 3A FD 60    >        ld a,(UNITTEST_SAVE_REG)
118+  6249               TC_END
118+  6249 C3 93 60    >        jp UNITTEST_TEST_READY_SUCCESS
119+  624C
120+  624C
121+  624C              FILL_MEMORY_SIZE:   equ 10
122+  624C 00               defb 0
123+  624D              fill_memory_data:
124+  624D 00 00 00...      defs 10
125+  6257 00               defb 0
126+  6258
127+  6258
128+  6258              ; Tests filling a line in the background color screen.
129+  6258              UT_fill_bckg_line_normal:
130+  6258                  ; Initialize background
131+  6258 CD 52 60         call clear_backg
132+  625B
133+  625B                  ; Fill line with color
134+  625B 3E 18            ld a,MAGENTA
135+  625D 11 00 58         ld de,COLOR_SCREEN
136+  6260 CD 17 60         call fill_bckg_line
137+  6263
138+  6263                  ; Test that line is filled
139+  6263                  TEST_MEMORY_BYTE COLOR_SCREEN, MAGENTA
139+  6263 32 FD 60    >        ld (UNITTEST_SAVE_REG),a
139+  6266 3A 00 58    >        ld a,(COLOR_SCREEN)
139+  6269 FE 18       >        cp MAGENTA
139+  626B C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE
139+  626E 3A FD 60    >        ld a,(UNITTEST_SAVE_REG)
140+  6271                  TEST_MEMORY_BYTE COLOR_SCREEN+16, MAGENTA
140+  6271 32 FD 60    >        ld (UNITTEST_SAVE_REG),a
140+  6274 3A 10 58    >        ld a,(COLOR_SCREEN+16)
140+  6277 FE 18       >        cp MAGENTA
140+  6279 C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE
140+  627C 3A FD 60    >        ld a,(UNITTEST_SAVE_REG)
141+  627F                  TEST_MEMORY_BYTE COLOR_SCREEN+31, MAGENTA
141+  627F 32 FD 60    >        ld (UNITTEST_SAVE_REG),a
141+  6282 3A 1F 58    >        ld a,(COLOR_SCREEN+31)
141+  6285 FE 18       >        cp MAGENTA
141+  6287 C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE
141+  628A 3A FD 60    >        ld a,(UNITTEST_SAVE_REG)
142+  628D                  TEST_MEMORY_BYTE COLOR_SCREEN+32, 0
142+  628D 32 FD 60    >        ld (UNITTEST_SAVE_REG),a
142+  6290 3A 20 58    >        ld a,(COLOR_SCREEN+32)
142+  6293 FE 00       >        cp 0
142+  6295 C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE
142+  6298 3A FD 60    >        ld a,(UNITTEST_SAVE_REG)
143+  629B
144+  629B                  ; Test that de points to the next line
145+  629B                  TEST_DREG de, COLOR_SCREEN+32
145+  629B D5          >        push de
145+  629C E5          >        push hl
145+  629D D5          >        push de
145+  629E E1          >        pop hl
145+  629F 11 20 58    >        ld de,COLOR_SCREEN+32
145+  62A2 B7          >        or a
145+  62A3 ED 52       >        sbc hl,de
145+  62A5 E1          >        pop hl
145+  62A6 D1          >        pop de
145+  62A7 C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE ; de = (addr)
145+  62AA 00          >        nop
146+  62AB               TC_END
146+  62AB C3 93 60    >        jp UNITTEST_TEST_READY_SUCCESS
147+  62AE
148+  62AE              ; Test wrap around.
149+  62AE              UT_fill_bckg_line_wrap_around:
150+  62AE                  ; Initialize background
151+  62AE CD 52 60         call clear_backg
152+  62B1
153+  62B1                  ; Fill line with color
154+  62B1 3E 18            ld a,MAGENTA
155+  62B3 11 E0 5A         ld de,COLOR_SCREEN+23*32
156+  62B6 CD 17 60         call fill_bckg_line
157+  62B9
158+  62B9                  ; Test that line is filled
159+  62B9                  TEST_MEMORY_BYTE COLOR_SCREEN+23*32, MAGENTA
159+  62B9 32 FD 60    >        ld (UNITTEST_SAVE_REG),a
159+  62BC 3A E0 5A    >        ld a,(COLOR_SCREEN+23*32)
159+  62BF FE 18       >        cp MAGENTA
159+  62C1 C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE
159+  62C4 3A FD 60    >        ld a,(UNITTEST_SAVE_REG)
160+  62C7                  TEST_MEMORY_BYTE COLOR_SCREEN+23*32+16, MAGENTA
160+  62C7 32 FD 60    >        ld (UNITTEST_SAVE_REG),a
160+  62CA 3A F0 5A    >        ld a,(COLOR_SCREEN+23*32+16)
160+  62CD FE 18       >        cp MAGENTA
160+  62CF C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE
160+  62D2 3A FD 60    >        ld a,(UNITTEST_SAVE_REG)
161+  62D5                  TEST_MEMORY_BYTE COLOR_SCREEN+23*32+31, MAGENTA
161+  62D5 32 FD 60    >        ld (UNITTEST_SAVE_REG),a
161+  62D8 3A FF 5A    >        ld a,(COLOR_SCREEN+23*32+31)
161+  62DB FE 18       >        cp MAGENTA
161+  62DD C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE
161+  62E0 3A FD 60    >        ld a,(UNITTEST_SAVE_REG)
162+  62E3                  TEST_MEMORY_BYTE COLOR_SCREEN+23*32-1, 0
162+  62E3 32 FD 60    >        ld (UNITTEST_SAVE_REG),a
162+  62E6 3A DF 5A    >        ld a,(COLOR_SCREEN+23*32-1)
162+  62E9 FE 00       >        cp 0
162+  62EB C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE
162+  62EE 3A FD 60    >        ld a,(UNITTEST_SAVE_REG)
163+  62F1
164+  62F1                  ; Test that de points to the first line (wrap around)
165+  62F1                  TEST_DREG de, COLOR_SCREEN
165+  62F1 D5          >        push de
165+  62F2 E5          >        push hl
165+  62F3 D5          >        push de
165+  62F4 E1          >        pop hl
165+  62F5 11 00 58    >        ld de,COLOR_SCREEN
165+  62F8 B7          >        or a
165+  62F9 ED 52       >        sbc hl,de
165+  62FB E1          >        pop hl
165+  62FC D1          >        pop de
165+  62FD C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE ; de = (addr)
165+  6300 00          >        nop
166+  6301               TC_END
166+  6301 C3 93 60    >        jp UNITTEST_TEST_READY_SUCCESS
167+  6304
168+  6304
169+  6304              ; Test wrap around.
170+  6304              UT_fill_colors_ptr:
171+  6304                  ; Start value
172+  6304 21 41 60         ld hl,fill_colors
173+  6307 22 3F 60         ld (fill_colors_ptr),hl
174+  630A
175+  630A                  ; Test increment
176+  630A CD 2A 60         call inc_fill_colors_ptr
177+  630D                  ; Test that pointer is moved to next line
178+  630D                  TEST_MEMORY_WORD fill_colors_ptr, fill_colors+1
178+  630D D5          >        push de
178+  630E E5          >        push hl
178+  630F 21 42 60    >        ld hl,fill_colors+1
178+  6312 ED 5B 3F 60 >        ld de,(fill_colors_ptr)
178+  6316 B7          >        or a
178+  6317 ED 52       >        sbc hl,de
178+  6319 E1          >        pop hl
178+  631A C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE ; de = (addr)
178+  631D D1          >        pop de
179+  631E
180+  631E                  ; Test increment
181+  631E CD 2A 60         call inc_fill_colors_ptr
182+  6321                  ; Test that pointer is moved to next line
183+  6321                  TEST_MEMORY_WORD fill_colors_ptr, fill_colors+2
183+  6321 D5          >        push de
183+  6322 E5          >        push hl
183+  6323 21 43 60    >        ld hl,fill_colors+2
183+  6326 ED 5B 3F 60 >        ld de,(fill_colors_ptr)
183+  632A B7          >        or a
183+  632B ED 52       >        sbc hl,de
183+  632D E1          >        pop hl
183+  632E C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE ; de = (addr)
183+  6331 D1          >        pop de
184+  6332
185+  6332                  ; Last value
186+  6332 21 45 60         ld hl,fill_colors_end-1
187+  6335 22 3F 60         ld (fill_colors_ptr),hl
188+  6338
189+  6338                  ; Test increment
190+  6338 CD 2A 60         call inc_fill_colors_ptr
191+  633B                  ; Test that pointer wraps around and points to first line
192+  633B                  TEST_MEMORY_WORD fill_colors_ptr, fill_colors
192+  633B D5          >        push de
192+  633C E5          >        push hl
192+  633D 21 41 60    >        ld hl,fill_colors
192+  6340 ED 5B 3F 60 >        ld de,(fill_colors_ptr)
192+  6344 B7          >        or a
192+  6345 ED 52       >        sbc hl,de
192+  6347 E1          >        pop hl
192+  6348 C4 91 60    >        call nz,UNITTEST_TEST_READY_FAILURE ; de = (addr)
192+  634B D1          >        pop de
193+  634C               TC_END
193+  634C C3 93 60    >        jp UNITTEST_TEST_READY_SUCCESS
194+  634F
195+  634F                  ENDMODULE
196+  634F
197+  634F
# file closed: unit_tests.asm
 44   634F
 45   634F
 46   634F              ;===========================================================================
 47   634F              ; main routine - the code execution starts here.
 48   634F              ; Sets up the new interrupt routine, the memory
 49   634F              ; banks and jumps to the start loop.
 50   634F              ;===========================================================================
 51   634F
 52   634F               ORG $8000
 53   8000
 54   8000              main:
 55   8000                  ; Disable interrupts
 56   8000 F3               di
 57   8001 31 2C 81         ld sp,stack_top
 58   8004
 59   8004                  ; CLS
 60   8004 CD 47 60         call clear_screen
 61   8007 CD 52 60         call clear_backg
 62   800A
 63   800A                  ; Init
 64   800A              lbl1:
 65   800A 21 41 60         ld hl,fill_colors
 66   800D 22 3F 60         ld (fill_colors_ptr),hl
 67   8010 11 00 58         ld de,COLOR_SCREEN
 68   8013
 69   8013                  ; Enable interrupts
 70   8013                  ;im 1
 71   8013                  ;ei
 72   8013
 73   8013              main_loop:
 74   8013                  ; fill line with color
 75   8013 2A 3F 60         ld hl,(fill_colors_ptr)
 76   8016 7E               ld a,(hl)
 77   8017 CD 17 60         call fill_bckg_line
 78   801A
 79   801A                  ; break
 80   801A D5               push de
 81   801B 11 F4 01         ld de,PAUSE_TIME
 82   801E CD 01 60         call pause
 83   8021 D1               pop de
 84   8022
 85   8022                  ; Alternatively wait on vertical interrupt
 86   8022                  ;halt
 87   8022
 88   8022                  ; next line
 89   8022 CD 2A 60         call inc_fill_colors_ptr
 90   8025
 91   8025 18 EC            jr main_loop
 92   8027
 93   8027
 94   8027              ;===========================================================================
 95   8027              ; Stack.
 96   8027              ;===========================================================================
 97   8027
 98   8027 3A 31 80      ld a,(rb_continue.bp1_address)
 99   802A
100   802A
101   802A                  STRUCT RECEIVE_BUFFER_CMD_CONTINUE
102   802A ~            bp1_enable          BYTE    0
103   802A ~            bp1_address         WORD    0
104   802A ~            bp2_enable          BYTE    0
105   802A ~            bp2_address         WORD    0
106   802A                  ENDS
107   802A
108   802A              receive_buffer:
109   802A 00 00 00...      defs 6
110   8030              .payload
111   8030 00 00 00...      defs 50
112   8062
113   8062              ; definie alias labels for "receive_buffer" to access specific-command fields
114   8062              rb_continue    RECEIVE_BUFFER_CMD_CONTINUE = receive_buffer.payload
115   8062
116   8062
117   8062
118   8062              ; Stack: this area is reserved for the stack
119   8062              STACK_SIZE: equ 100    ; in words
120   8062
121   8062
122   8062              ; Reserve stack space
123   8062 00 00            defw 0  ; WPMEM, 2
124   8064              stack_bottom:
125   8064 00 00 00...      defs    STACK_SIZE*2, 0
126   812C              stack_top:
127   812C                  ;defw 0
128   812C 00 00            defw 0  ; WPMEM, 2
129   812E
130   812E
131   812E
132   812E                  IF NEX == 0
133   812E ~                    SAVESNA "z80-sample-program.sna", main
134   812E                  ELSE
135   812E                      SAVENEX OPEN "z80-sample-program.nex", main, stack_top
136   812E                      SAVENEX CORE 2, 0, 0        ; Next core 2.0.0 required as minimum
137   812E                      SAVENEX CFG 7   ; Border color
138   812E                      SAVENEX AUTO
139   812E                      SAVENEX CLOSE
140   812E                  ENDIF
141   812E
# file closed: main.asm

Value    Label
------ - -----------------------------------------------------------
0x0001   NEX
0x6000 X screen_top
0x01F4   PAUSE_TIME
0x6001   pause
0x6003   pause_loop_l2
0x6005   pause_loop_l1
0x0020   BCKG_LINE_SIZE
0x0000 X BLACK
0x0008   BLUE
0x0010   RED
0x0018   MAGENTA
0x0020   GREEN
0x0028 X CYAN
0x0030   YELLOW
0x0038 X WHITE
0x600F   fill_memory
0x6017   fill_bckg_line
0x5800   COLOR_SCREEN
0x0300   COLOR_SCREEN_SIZE
0x602A   inc_fill_colors_ptr
0x603F   fill_colors_ptr
0x6046   fill_colors_end
0x6041   fill_colors
0x4000   SCREEN
0x1800   SCREEN_SIZE
0x6047   clear_screen
0x6052   clear_backg
0x6057   fill_backg
0x0000   dezog_magic_number_a
0x0001   dezog_magic_number_b
0x0066   dezog_magic_number_c
0x0067   dezog_magic_number_d
0x0018   DEZOG_MAGIC_NUMBER_VALUE_A
0x0064   DEZOG_MAGIC_NUMBER_VALUE_B
0x00F5   DEZOG_MAGIC_NUMBER_VALUE_C
0x00ED   DEZOG_MAGIC_NUMBER_VALUE_D
0x6061 X dezog_init_slot0_bank
0x607C   dezog_init_slot0_bank.push
0x6087 X UNITTEST_TEST_WRAPPER
0x60FB   UNITTEST_STACK
0x608B X UNITTEST_CALL_ADDR
0x608F   UNITTEST_TEST_READY_RETURN_FAILURE
0x6091   UNITTEST_TEST_READY_FAILURE
0x6092 X UNITTEST_TEST_READY_FAILURE_BREAKPOINT
0x6093   UNITTEST_TEST_READY_SUCCESS
0x6095 X UNITTEST_MIN_STACK_GUARD
0x60FB X UNITTEST_MAX_STACK_GUARD
0x60FD   UNITTEST_SAVE_REG
0x60FF X UNITTEST_START
0x6101 X TestSuite_ClearScreen.UT_clear_screen
0x614D X TestSuite_ClearScreen.UT_fill_backg
0x619B X TestSuite_ClearScreen.UT_clear_backg
0x61E7 X TestSuite_Fill.UT_fill_memory
0x624D   TestSuite_Fill.fill_memory_data
0x000A   TestSuite_Fill.FILL_MEMORY_SIZE
0x6258 X TestSuite_Fill.UT_fill_bckg_line_normal
0x62AE X TestSuite_Fill.UT_fill_bckg_line_wrap_around
0x6304 X TestSuite_Fill.UT_fill_colors_ptr
0x8000 X main
0x812C   stack_top
0x800A X lbl1
0x8013   main_loop
0x8031   rb_continue.bp1_address
0x0006 X RECEIVE_BUFFER_CMD_CONTINUE
0x0000 X RECEIVE_BUFFER_CMD_CONTINUE.bp1_enable
0x0001 X RECEIVE_BUFFER_CMD_CONTINUE.bp1_address
0x0003 X RECEIVE_BUFFER_CMD_CONTINUE.bp2_enable
0x0004 X RECEIVE_BUFFER_CMD_CONTINUE.bp2_address
0x802A X receive_buffer
0x8030   receive_buffer.payload
0x8030 X rb_continue
0x8030 X rb_continue.bp1_enable
0x8033 X rb_continue.bp2_enable
0x8034 X rb_continue.bp2_address
0x0064   STACK_SIZE
0x8064 X stack_bottom
